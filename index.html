<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Recall Matrix</title>
  <style>
    :root {
      --bg: #020617;
      --panel: #020c1a;
      --accent: #10f7a4;
      --accent-soft: rgba(16, 247, 164, 0.12);
      --danger: #f97373;
      --text: #e5f5ff;
      --muted: #64748b;
      --border: #0f172a;
      --font-main: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
                   "Segoe UI", sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #0b1220 0, #020617 55%, #000 100%);
      color: var(--text);
      font-family: var(--font-main);
    }

    .frame {
      width: 480px;
      max-width: 95vw;
      background: linear-gradient(to bottom, #020617, #020c1a);
      border-radius: 18px;
      border: 1px solid #0b1220;
      box-shadow:
        0 0 0 1px rgba(16, 185, 129, 0.1),
        0 24px 60px rgba(15, 23, 42, 0.8);
      overflow: hidden;
    }

    .frame-header {
      padding: 12px 18px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid var(--border);
      background: radial-gradient(circle at top left, #0f172a, #020617);
      font-size: 13px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .header-left span:first-child {
      color: var(--accent);
    }

    .header-left span:last-child {
      color: var(--muted);
      margin-left: 8px;
      font-size: 11px;
      text-transform: none;
      letter-spacing: normal;
    }

    .header-right {
      display: flex;
      gap: 10px;
      align-items: center;
      font-size: 11px;
      color: var(--muted);
    }

    .pill {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #0f172a;
      background: rgba(15, 23, 42, 0.7);
    }

    .frame-body {
      padding: 18px 18px 20px;
    }

    .progress-bar {
      width: 100%;
      height: 4px;
      border-radius: 999px;
      background: #020617;
      overflow: hidden;
      border: 1px solid #020617;
      margin-bottom: 26px;
    }

    .progress-fill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, #22c55e, #06b6d4);
      transition: width 0.1s linear;
    }

    .word-display {
      text-align: center;
      margin-bottom: 24px;
    }

    .label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .word {
      font-size: 32px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      font-weight: 700;
    }

    .buttons-row {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      margin-bottom: 18px;
    }

    button {
      font-family: var(--font-main);
      border-radius: 999px;
      border: none;
      font-size: 14px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      cursor: pointer;
      padding: 12px 10px;
      transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.08s;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    button:active {
      transform: translateY(1px) scale(0.99);
      box-shadow: none;
    }

    .btn-seen {
      background: var(--accent);
      color: #00100a;
      box-shadow: 0 0 18px rgba(16, 247, 164, 0.35);
    }

    .btn-new {
      background: #020617;
      color: #e2e8f0;
      border: 1px solid #0f172a;
      box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.9);
    }

    .btn-main {
      grid-column: span 2;
      margin-top: 4px;
      background: #0f172a;
      color: var(--muted);
      border-radius: 12px;
      border: 1px solid #020617;
      font-size: 12px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      padding: 10px;
    }

    .btn-main span {
      font-weight: 600;
      color: var(--accent);
      margin-right: 4px;
    }

    .btn-disabled {
      opacity: 0.4;
      cursor: default;
      box-shadow: none;
    }

    .stats-bar {
      display: flex;
      justify-content: space-between;
      margin-top: 10px;
      font-size: 11px;
      color: var(--muted);
    }

    .stat {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .stat-label {
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-size: 10px;
    }

    .stat-value {
      font-size: 12px;
      color: #e2e8f0;
    }

    .stat-value.good { color: var(--accent); }
    .stat-value.bad { color: var(--danger); }

    .footer {
      margin-top: 10px;
      font-size: 10px;
      text-align: center;
      color: #475569;
      border-top: 1px solid #0b1220;
      padding-top: 10px;
    }

    .hint {
      margin-top: 4px;
      font-size: 10px;
      color: #64748b;
    }

    .status-message {
      margin-top: 8px;
      font-size: 12px;
      text-align: center;
      color: var(--muted);
      min-height: 16px;
    }

    .status-message.good { color: var(--accent); }
    .status-message.bad { color: var(--danger); }
  </style>
</head>
<body>
  <div class="frame">
    <div class="frame-header">
      <div class="header-left">
        <span>&gt;_ RECALL MATRIX</span>
        <span>3s / word · 18 to pass</span>
      </div>
      <div class="header-right">
        <div class="pill">CPU 63%</div>
        <div class="pill">MEM 71%</div>
      </div>
    </div>

    <div class="frame-body">
      <div class="progress-bar">
        <div id="progressFill" class="progress-fill"></div>
      </div>

      <div class="word-display">
        <div class="label">CURRENT TOKEN</div>
        <div id="word" class="word">PRESS START</div>
      </div>

      <div class="buttons-row">
        <button id="btnSeen" class="btn-seen btn-disabled">SEEN</button>
        <button id="btnNew" class="btn-new btn-disabled">NEW</button>
        <button id="btnStart" class="btn-main">
          <span>ENTER</span> START SESSION
        </button>
      </div>

      <div class="stats-bar">
        <div class="stat">
          <div class="stat-label">STREAK</div>
          <div id="streakValue" class="stat-value good">0 / 18</div>
        </div>
        <div class="stat">
          <div class="stat-label">FAILSTATE</div>
          <div id="failValue" class="stat-value bad">0 / 1</div>
        </div>
        <div class="stat">
          <div class="stat-label">TIME / WORD</div>
          <div class="stat-value">3.0s</div>
        </div>
      </div>

      <div id="status" class="status-message">
        Click START to begin. One mistake ends the run.
      </div>

      <div class="footer">
        System secure. Access pending. Awaiting commands.
        <div class="hint">
          Hotkeys: [S] = Seen · [N] = New · [Enter] = Start / Restart
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====== CONFIG ======
    const TARGET_STREAK = 18;
    const TIME_PER_ROUND_MS = 3000;

    const WORDS = [
      "CRONJOB", "PAYLOAD", "MODULE", "VECTOR", "THREAD", "KERNEL",
      "PROTOCOL", "PACKET", "SESSION", "HANDLER", "DAEMON", "UPLINK",
      "DOWNLINK", "LOOPBACK", "METADATA", "CHECKSUM", "ENDPOINT",
      "INSTANCE", "RUNTIME", "PIPELINE", "STORAGE", "DATABASE",
      "OVERFLOW", "FIREWALL", "GATEWAY", "PROXY", "REQUEST", "RESPONSE",
      "SERVICE", "TRIGGER", "WATCHDOG", "PATCHER", "SEQUENCE", "STREAM",
      "BINARY", "INDEX", "CIPHER", "SHARD", "CLUSTER", "BYPASS",
      "CAPTURE", "RENDER", "EXECUTE", "RESOLVE", "COMPILE", "DEPLOY",
      "INITIATE", "DISPATCH", "LISTENER", "SIGNATURE", "VERSION",
      "HOTFIX", "SUBSYSTEM", "MAINFRAME", "REGISTRY", "SIGNAL"
    ];

    // ====== STATE ======
    let seenWords = new Set();
    let wordUsage = new Map(); // tracks how many times each word has appeared
    let currentWord = "";
    let lastWord = "";
    let isCurrentSeen = false;
    let streak = 0;
    let fails = 0;
    let timerId = null;
    let timeRemaining = TIME_PER_ROUND_MS;
    let roundActive = false;
    let gameOver = false;

    // ====== DOM ======
    const wordEl = document.getElementById("word");
    const btnSeen = document.getElementById("btnSeen");
    const btnNew = document.getElementById("btnNew");
    const btnStart = document.getElementById("btnStart");
    const streakValueEl = document.getElementById("streakValue");
    const failValueEl = document.getElementById("failValue");
    const statusEl = document.getElementById("status");
    const progressFill = document.getElementById("progressFill");

    // ====== HELPERS ======
    function randItem(arr) {
      return arr[Math.floor(Math.random() * arr.length)];
    }

    function usageOf(word) {
      return wordUsage.get(word) || 0;
    }

    // Pick a word that:
    //  - avoids repeating lastWord when possible
    //  - prefers words with the lowest usage so far (more variety)
    function pickBalanced(arr, avoidWord) {
      if (arr.length === 0) return null;

      let candidates = arr;
      if (avoidWord && arr.length > 1) {
        const filtered = arr.filter(w => w !== avoidWord);
        if (filtered.length > 0) candidates = filtered;
      }

      let minUsage = Infinity;
      for (const w of candidates) {
        const u = usageOf(w);
        if (u < minUsage) minUsage = u;
      }

      const leastUsed = candidates.filter(w => usageOf(w) === minUsage);
      return randItem(leastUsed);
    }

    function setButtonsEnabled(enabled) {
      const method = enabled ? "remove" : "add";
      btnSeen.classList[method]("btn-disabled");
      btnNew.classList[method]("btn-disabled");
    }

    function resetProgressBar() {
      progressFill.style.width = "100%";
    }

    function startTimer() {
      clearInterval(timerId);
      timeRemaining = TIME_PER_ROUND_MS;
      resetProgressBar();

      timerId = setInterval(() => {
        timeRemaining -= 100;
        if (timeRemaining <= 0) {
          clearInterval(timerId);
          progressFill.style.width = "0%";
          if (roundActive) {
            handleFail("Timed out.");
          }
          return;
        }
        const pct = (timeRemaining / TIME_PER_ROUND_MS) * 100;
        progressFill.style.width = pct + "%";
      }, 100);
    }

    function updateStats() {
      streakValueEl.textContent = `${streak} / ${TARGET_STREAK}`;
      failValueEl.textContent = `${fails} / 1`;
    }

    function setStatus(msg, type = "") {
      statusEl.textContent = msg;
      statusEl.classList.remove("good", "bad");
      if (type === "good") statusEl.classList.add("good");
      if (type === "bad") statusEl.classList.add("bad");
    }

    function generateRound() {
      const unseen = WORDS.filter(w => !seenWords.has(w));

      // Decide mode (seen/new) – bias to NEW while there are many unseen
      let mode;
      if (seenWords.size === 0) {
        mode = "new";
      } else if (unseen.length === 0) {
        mode = "seen";
      } else {
        const pNew = 0.65; // 65% chance to show a NEW word while we still have some
        mode = Math.random() < pNew ? "new" : "seen";
      }

      let candidate = null;

      if (mode === "seen") {
        const arr = Array.from(seenWords);
        candidate = pickBalanced(arr, lastWord);
        isCurrentSeen = true;
      } else {
        candidate = pickBalanced(unseen, lastWord);
        isCurrentSeen = false;
      }

      if (!candidate) {
        candidate = pickBalanced(WORDS, lastWord) || randItem(WORDS);
        isCurrentSeen = seenWords.has(candidate);
      }

      currentWord = candidate;
      lastWord = candidate;

      // bump usage count for variety tracking
      wordUsage.set(currentWord, usageOf(currentWord) + 1);

      wordEl.textContent = currentWord;
      roundActive = true;
      setButtonsEnabled(true);
      setStatus("Classify token: seen before or new?");
      startTimer();
    }

    function startGame() {
      seenWords = new Set();
      wordUsage = new Map();
      currentWord = "";
      lastWord = "";
      streak = 0;
      fails = 0;
      gameOver = false;
      updateStats();
      setStatus("Session live. One mistake ends the run.", "good");
      wordEl.textContent = "READY...";
      setButtonsEnabled(false);

      clearInterval(timerId);
      progressFill.style.width = "100%";

      setTimeout(() => {
        generateRound();
      }, 400);
    }

    function handleFail(reason) {
      roundActive = false;
      gameOver = true;
      fails = 1;
      updateStats();
      setButtonsEnabled(false);
      wordEl.textContent = "ACCESS DENIED";
      setStatus(`${reason} Run terminated. Press START to try again.`, "bad");
    }

    function handleWin() {
      roundActive = false;
      gameOver = true;
      setButtonsEnabled(false);
      clearInterval(timerId);
      wordEl.textContent = "ACCESS GRANTED";
      setStatus("Perfect streak achieved. System unlocked.", "good");
    }

    function handleChoice(choice) {
      if (!roundActive || gameOver) return;
      if (choice !== "seen" && choice !== "new") return;

      roundActive = false;
      clearInterval(timerId);
      setButtonsEnabled(false);

      const correct =
        (choice === "seen" && isCurrentSeen) ||
        (choice === "new" && !isCurrentSeen);

      if (correct) {
        streak++;
        seenWords.add(currentWord); // token has now been seen in this run
        updateStats();

        if (streak >= TARGET_STREAK) {
          handleWin();
        } else {
          setStatus("Correct. Preparing next token...", "good");
          setTimeout(() => {
            generateRound();
          }, 350);
        }
      } else {
        handleFail("Incorrect classification.");
      }
    }

    // ====== EVENTS ======
    btnStart.addEventListener("click", startGame);
    btnSeen.addEventListener("click", () => handleChoice("seen"));
    btnNew.addEventListener("click", () => handleChoice("new"));

    document.addEventListener("keydown", (e) => {
      if (e.code === "Enter") {
        startGame();
      } else if (e.key === "s" || e.key === "S") {
        handleChoice("seen");
      } else if (e.key === "n" || e.key === "N") {
        handleChoice("new");
      }
    });
  </script>
</body>
</html>
